<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>7&nbsp; Graph Algorithms and Traversal – Knowledge Graphs: Foundations, Applications, and Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../contents/construction/stat-analysis-of-kg.html" rel="next">
<link href="../../contents/construction/kg-construction.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-bdec3157979715d7154bb60f5aa24e58.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../contents/construction/kg-construction.html">Construction and processing</a></li><li class="breadcrumb-item"><a href="../../contents/construction/kg-algorithms.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Graph Algorithms and Traversal</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Knowledge Graphs: Foundations, Applications, and Analysis</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Introduction</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/foundation/outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Outline</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/foundation/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to knowledge graphs and network science</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/foundation/math-fundamentals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Mathematical fundamentals</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/foundation/graph-fundamentals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Graph Theory Fundamentals</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/foundation/knowledge-representation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Knowledge Representation and Ontologies</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Construction and processing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/construction/kg-construction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Knowledge Graph Construction</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/construction/kg-algorithms.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Graph Algorithms and Traversal</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/construction/stat-analysis-of-kg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Statistical Analysis of Knowledge Graphs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/construction/ml-on-kg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Machine Learning on Knowledge Graphs</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="-1">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-to-graph-algorithms" id="toc-introduction-to-graph-algorithms" class="nav-link active" data-scroll-target="#introduction-to-graph-algorithms"><span class="header-section-number">7.1</span> Introduction to graph algorithms</a></li>
  <li><a href="#graph-traversal-fundamentals" id="toc-graph-traversal-fundamentals" class="nav-link" data-scroll-target="#graph-traversal-fundamentals"><span class="header-section-number">7.2</span> Graph traversal fundamentals</a>
  <ul class="collapse">
  <li><a href="#breadth-first-search" id="toc-breadth-first-search" class="nav-link" data-scroll-target="#breadth-first-search"><span class="header-section-number">7.2.1</span> Breadth-first search</a></li>
  <li><a href="#depth-first-search" id="toc-depth-first-search" class="nav-link" data-scroll-target="#depth-first-search"><span class="header-section-number">7.2.2</span> Depth-first search</a></li>
  <li><a href="#comparison-of-bfs-and-dfs" id="toc-comparison-of-bfs-and-dfs" class="nav-link" data-scroll-target="#comparison-of-bfs-and-dfs"><span class="header-section-number">7.2.3</span> Comparison of BFS and DFS</a></li>
  </ul></li>
  <li><a href="#shortest-path-algorithms" id="toc-shortest-path-algorithms" class="nav-link" data-scroll-target="#shortest-path-algorithms"><span class="header-section-number">7.3</span> Shortest path algorithms</a>
  <ul class="collapse">
  <li><a href="#dijkstras-algorithm" id="toc-dijkstras-algorithm" class="nav-link" data-scroll-target="#dijkstras-algorithm"><span class="header-section-number">7.3.1</span> Dijkstra’s algorithm</a></li>
  <li><a href="#a-algorithm" id="toc-a-algorithm" class="nav-link" data-scroll-target="#a-algorithm"><span class="header-section-number">7.3.2</span> A* algorithm</a></li>
  <li><a href="#bellman-ford-algorithm" id="toc-bellman-ford-algorithm" class="nav-link" data-scroll-target="#bellman-ford-algorithm"><span class="header-section-number">7.3.3</span> Bellman-Ford algorithm</a></li>
  </ul></li>
  <li><a href="#minimum-spanning-trees" id="toc-minimum-spanning-trees" class="nav-link" data-scroll-target="#minimum-spanning-trees"><span class="header-section-number">7.4</span> Minimum spanning trees</a>
  <ul class="collapse">
  <li><a href="#kruskals-algorithm" id="toc-kruskals-algorithm" class="nav-link" data-scroll-target="#kruskals-algorithm"><span class="header-section-number">7.4.1</span> Kruskal’s algorithm</a></li>
  <li><a href="#prims-algorithm" id="toc-prims-algorithm" class="nav-link" data-scroll-target="#prims-algorithm"><span class="header-section-number">7.4.2</span> Prim’s algorithm</a></li>
  </ul></li>
  <li><a href="#topological-sorting" id="toc-topological-sorting" class="nav-link" data-scroll-target="#topological-sorting"><span class="header-section-number">7.5</span> Topological sorting</a></li>
  <li><a href="#graph-coloring-and-matching-problems" id="toc-graph-coloring-and-matching-problems" class="nav-link" data-scroll-target="#graph-coloring-and-matching-problems"><span class="header-section-number">7.6</span> Graph coloring and matching problems</a></li>
  <li><a href="#algorithm-complexity-analysis-for-graph-operations" id="toc-algorithm-complexity-analysis-for-graph-operations" class="nav-link" data-scroll-target="#algorithm-complexity-analysis-for-graph-operations"><span class="header-section-number">7.7</span> Algorithm complexity analysis for graph operations</a>
  <ul class="collapse">
  <li><a href="#time-complexity" id="toc-time-complexity" class="nav-link" data-scroll-target="#time-complexity"><span class="header-section-number">7.7.1</span> Time complexity</a></li>
  <li><a href="#space-complexity" id="toc-space-complexity" class="nav-link" data-scroll-target="#space-complexity"><span class="header-section-number">7.7.2</span> Space complexity</a></li>
  <li><a href="#performance-considerations-for-knowledge-graphs" id="toc-performance-considerations-for-knowledge-graphs" class="nav-link" data-scroll-target="#performance-considerations-for-knowledge-graphs"><span class="header-section-number">7.7.3</span> Performance considerations for knowledge graphs</a></li>
  </ul></li>
  <li><a href="#applications-in-knowledge-graph-analysis" id="toc-applications-in-knowledge-graph-analysis" class="nav-link" data-scroll-target="#applications-in-knowledge-graph-analysis"><span class="header-section-number">7.8</span> Applications in knowledge graph analysis</a>
  <ul class="collapse">
  <li><a href="#path-based-inference" id="toc-path-based-inference" class="nav-link" data-scroll-target="#path-based-inference"><span class="header-section-number">7.8.1</span> Path-based inference</a></li>
  <li><a href="#community-detection" id="toc-community-detection" class="nav-link" data-scroll-target="#community-detection"><span class="header-section-number">7.8.2</span> Community detection</a></li>
  <li><a href="#centrality-analysis" id="toc-centrality-analysis" class="nav-link" data-scroll-target="#centrality-analysis"><span class="header-section-number">7.8.3</span> Centrality analysis</a></li>
  </ul></li>
  <li><a href="#recursive-and-iterative-approaches" id="toc-recursive-and-iterative-approaches" class="nav-link" data-scroll-target="#recursive-and-iterative-approaches"><span class="header-section-number">7.9</span> Recursive and iterative approaches</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">7.10</span> Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../contents/construction/kg-construction.html">Construction and processing</a></li><li class="breadcrumb-item"><a href="../../contents/construction/kg-algorithms.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Graph Algorithms and Traversal</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Graph Algorithms and Traversal</span></h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<p>I’ll write Chapter 6: Graph Algorithms and Traversal for your knowledge graph book, following your guidelines for content and format. I’ll create comprehensive yet accessible material suitable for students with diverse backgrounds in computer science and economics, maintaining appropriate rigor while providing necessary explanations.</p>
<section id="introduction-to-graph-algorithms" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="introduction-to-graph-algorithms"><span class="header-section-number">7.1</span> Introduction to graph algorithms</h2>
<p>Knowledge graphs, as specialized graph structures, can be effectively analyzed and manipulated using algorithms developed in graph theory. This chapter explores fundamental algorithms for traversing, searching, and analyzing knowledge graphs, providing the computational foundation needed to extract value from these complex data structures.</p>
<p>Graph algorithms provide systematic approaches to solve various problems on graph structures, from finding the shortest path between entities to identifying communities within networks. While general graph algorithms apply to knowledge graphs, we need to consider the special characteristics of knowledge graphs, including their directed, labeled, and often weighted nature.</p>
<p>Before diving into specific algorithms, let’s establish why graph algorithms are particularly important for knowledge graph applications:</p>
<div id="def-graph-algorithm" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.1 (Graph algorithm)</strong></span> A <strong>graph algorithm</strong> is a well-defined computational procedure that takes a graph <span class="math inline">G = (V, E)</span> as input (possibly with additional parameters) and produces an output related to the structure or properties of the graph.</p>
</div>
</section>
<section id="graph-traversal-fundamentals" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="graph-traversal-fundamentals"><span class="header-section-number">7.2</span> Graph traversal fundamentals</h2>
<p>Graph traversal refers to the process of visiting (examining or updating) each vertex in a graph in a systematic way. Traversal algorithms form the foundation for many more complex graph operations.</p>
<div id="def-graph-traversal" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.2 (Graph traversal)</strong></span> A <strong>graph traversal</strong> is a systematic procedure for visiting every vertex and/or edge in a graph exactly once.</p>
</div>
<p>When applied to knowledge graphs, traversal becomes a mechanism for knowledge exploration and discovery. For example, a traversal might help identify all entities connected to a particular concept within three relationship hops.</p>
<section id="breadth-first-search" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="breadth-first-search"><span class="header-section-number">7.2.1</span> Breadth-first search</h3>
<p>Breadth-first search (BFS) is one of the most fundamental graph traversal algorithms, exploring all neighbors at the present depth before moving to vertices at the next depth level.</p>
<div id="def-breadth-first-search" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.3 (Breadth-first search)</strong></span> <strong>Breadth-first search (BFS)</strong> is a traversal algorithm that explores a graph by visiting all neighbors of a vertex before proceeding to neighbors of neighbors. Formally, given a graph <span class="math inline">G = (V, E)</span> and a source vertex <span class="math inline">s \in V</span>, BFS explores all vertices at distance <span class="math inline">k</span> from <span class="math inline">s</span> before exploring any vertex at distance <span class="math inline">k+1</span>.</p>
</div>
<div id="exm-bfs-algorithm" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.1 (BFS algorithm)</strong></span> &nbsp;</p>
<pre><code>BFS(G, s):
    for each vertex u in G.V - {s}
        u.color = WHITE
        u.distance = ∞
        u.predecessor = NIL
    s.color = GRAY
    s.distance = 0
    s.predecessor = NIL
    Q = empty queue
    ENQUEUE(Q, s)
    while Q is not empty
        u = DEQUEUE(Q)
        for each v in G.Adj[u]
            if v.color == WHITE
                v.color = GRAY
                v.distance = u.distance + 1
                v.predecessor = u
                ENQUEUE(Q, v)
        u.color = BLACK</code></pre>
<p>In this algorithm:</p>
<ul>
<li><p>WHITE: vertex has not been discovered</p></li>
<li><p>GRAY: vertex has been discovered but not all its neighbors have been explored</p></li>
<li><p>BLACK: vertex and all its neighbors have been explored</p></li>
</ul>
</div>
<div id="exm-bfs-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.2 (BFS in a knowledge graph)</strong></span> Consider a knowledge graph with entities representing scientific papers and relationships such as “cites” and “has-author”. If we run BFS starting from a seminal paper on knowledge graphs, we can identify all papers within two citation links, effectively mapping the close academic neighborhood of the original paper.</p>
<p>For example, starting with the entity “Resource Description Framework” (RDF):</p>
<ul>
<li><p>Level 0: “Resource Description Framework”</p></li>
<li><p>Level 1: “Web Ontology Language”, “RDF Schema”, “Semantic Web”</p></li>
<li><p>Level 2: “Description Logic”, “Knowledge Representation”, “Linked Data”</p></li>
</ul>
</div>
<p>The time complexity of BFS is <span class="math inline">O(|V| + |E|)</span> where <span class="math inline">|V|</span> is the number of vertices and <span class="math inline">|E|</span> is the number of edges. In knowledge graphs, where the number of relationships can be very large, this linear complexity is crucial for practical applications.</p>
</section>
<section id="depth-first-search" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="depth-first-search"><span class="header-section-number">7.2.2</span> Depth-first search</h3>
<p>While BFS explores breadth-wise, depth-first search (DFS) dives deeper into the graph before backtracking.</p>
<div id="def-depth-first-search" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.4 (Depth-first search)</strong></span> <strong>Depth-first search (DFS)</strong> is a traversal algorithm that explores as far as possible along each branch before backtracking. Given a graph <span class="math inline">G = (V, E)</span> and a source vertex, DFS first visits a neighbor of the source, then a neighbor of that neighbor, and so on, backtracking only when necessary.</p>
</div>
<div id="exm-dfs-algorithm" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.3 (DFS algorithm)</strong></span> &nbsp;</p>
<pre><code>DFS(G):
    for each vertex u in G.V
        u.color = WHITE
        u.predecessor = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u)

DFS-VISIT(G, u):
    time = time + 1
    u.discovery_time = time
    u.color = GRAY
    for each v in G.Adj[u]
        if v.color == WHITE
            v.predecessor = u
            DFS-VISIT(G, v)
    u.color = BLACK
    time = time + 1
    u.finish_time = time</code></pre>
</div>
<p>DFS has the same time complexity as BFS: <span class="math inline">O(|V| + |E|)</span>. However, its space complexity can be more efficient since it only needs to store vertices on the current exploration path.</p>
<div id="exm-dfs-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.4 (DFS in a knowledge graph)</strong></span> In a knowledge graph representing organizational hierarchy, DFS can trace complete reporting chains from top management to individual contributors. Starting from the CEO node, DFS would first explore one complete branch of the organization (e.g., CEO → VP of Engineering → Engineering Director → Engineering Manager → Engineer) before exploring other branches.</p>
</div>
<p>One important application of DFS in knowledge graphs is cycle detection. In a directed knowledge graph, cycles might represent inconsistencies or circular dependencies in knowledge representation.</p>
</section>
<section id="comparison-of-bfs-and-dfs" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="comparison-of-bfs-and-dfs"><span class="header-section-number">7.2.3</span> Comparison of BFS and DFS</h3>
<p>The choice between BFS and DFS depends on the specific application requirements:</p>
<ol type="1">
<li><p>BFS is preferred when:</p>
<ul>
<li>Finding the shortest path between nodes (in terms of number of edges)</li>
<li>Exploring the neighborhood structure around a node</li>
<li>Analyzing the spread of influence or information</li>
</ul></li>
<li><p>DFS is preferred when:</p>
<ul>
<li>Searching for paths with specific properties</li>
<li>Detecting cycles</li>
<li>Implementing topological sorting</li>
<li>Memory is a constraint (as DFS typically requires less memory)</li>
</ul></li>
</ol>
</section>
</section>
<section id="shortest-path-algorithms" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="shortest-path-algorithms"><span class="header-section-number">7.3</span> Shortest path algorithms</h2>
<p>Finding shortest paths in knowledge graphs has numerous applications, from identifying the closest connection between concepts to determining the most efficient way to navigate between entities.</p>
<div id="def-shortest-path" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.5 (Shortest path)</strong></span> A <strong>shortest path</strong> between vertices <span class="math inline">u</span> and <span class="math inline">v</span> in a weighted graph <span class="math inline">G = (V, E, w)</span> is a path <span class="math inline">P = (v_0, v_1, ..., v_k)</span> where <span class="math inline">v_0 = u</span>, <span class="math inline">v_k = v</span>, and the sum of edge weights <span class="math inline">\sum_{i=1}^{k} w(v_{i-1}, v_i)</span> is minimized.</p>
</div>
<p>In knowledge graphs, edge weights might represent relationship strength, confidence scores, or semantic distance between concepts.</p>
<section id="dijkstras-algorithm" class="level3" data-number="7.3.1">
<h3 data-number="7.3.1" class="anchored" data-anchor-id="dijkstras-algorithm"><span class="header-section-number">7.3.1</span> Dijkstra’s algorithm</h3>
<p>Dijkstra’s algorithm finds the shortest path from a single source vertex to all other vertices in a weighted graph with non-negative edge weights.</p>
<div id="def-dijkstra-algorithm" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.6 (Dijkstra’s algorithm)</strong></span> <strong>Dijkstra’s algorithm</strong> finds the shortest paths from a source vertex <span class="math inline">s</span> to all other vertices in a weighted graph <span class="math inline">G = (V, E, w)</span> with non-negative edge weights.</p>
</div>
<div id="exm-dijkstra-algorithm" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.5 (Dijkstra’s algorithm implementation)</strong></span> &nbsp;</p>
<pre><code>DIJKSTRA(G, w, s):
    for each vertex v in G.V
        v.distance = ∞
        v.predecessor = NIL
    s.distance = 0
    Q = G.V
    while Q is not empty
        u = EXTRACT-MIN(Q)  // Extract vertex with minimum distance
        for each vertex v in G.Adj[u]
            if v in Q and v.distance &gt; u.distance + w(u, v)
                v.distance = u.distance + w(u, v)
                v.predecessor = u
                DECREASE-KEY(Q, v, v.distance)</code></pre>
</div>
<p>The time complexity of Dijkstra’s algorithm using a binary heap is <span class="math inline">O((|V| + |E|) \log |V|)</span>.</p>
<div id="exm-dijkstra-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.6 (Dijkstra’s algorithm in a knowledge graph)</strong></span> Consider a biomedical knowledge graph where nodes represent diseases, symptoms, and treatments. Edges might be weighted by the strength of evidence supporting the relationship.</p>
<p>If we run Dijkstra’s algorithm from a disease node (e.g., “Type 2 Diabetes”), we can find the most strongly supported pathways to potential treatments. Edge weights could be computed as <span class="math inline">w(u,v) = -\log(
evidence\_strength(u,v))</span>, so that stronger evidence results in smaller weights.</p>
</div>
</section>
<section id="a-algorithm" class="level3" data-number="7.3.2">
<h3 data-number="7.3.2" class="anchored" data-anchor-id="a-algorithm"><span class="header-section-number">7.3.2</span> A* algorithm</h3>
<p>While Dijkstra’s algorithm is powerful, it explores in all directions equally. The A* algorithm improves efficiency by using a heuristic to guide the search toward the goal.</p>
<div id="def-a-star-algorithm" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.7 (A* algorithm)</strong></span> The <strong>A* algorithm</strong> is an informed search algorithm that finds the shortest path from a source vertex <span class="math inline">s</span> to a target vertex <span class="math inline">t</span> using a heuristic function <span class="math inline">h</span> that estimates the distance from any vertex to <span class="math inline">t</span>. A* maintains a priority queue of vertices based on the value <span class="math inline">f(v) = g(v) + h(v)</span>, where <span class="math inline">g(v)</span> is the known distance from <span class="math inline">s</span> to <span class="math inline">v</span>, and <span class="math inline">h(v)</span> is the estimated distance from <span class="math inline">v</span> to <span class="math inline">t</span>.</p>
</div>
<p>The heuristic function <span class="math inline">h(v)</span> must be admissible, meaning it never overestimates the actual cost to reach the goal. If <span class="math inline">h(v)</span> is admissible, A* is guaranteed to find the optimal path.</p>
<div id="exm-a-star-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.7 (A* in a knowledge graph)</strong></span> In a geographical knowledge graph where entities represent locations and relationships represent connections (roads, flights, etc.), A* can find the shortest route between two locations using straight-line distance as the heuristic. This focuses the search in the general direction of the destination, making it more efficient than Dijkstra’s algorithm.</p>
</div>
</section>
<section id="bellman-ford-algorithm" class="level3" data-number="7.3.3">
<h3 data-number="7.3.3" class="anchored" data-anchor-id="bellman-ford-algorithm"><span class="header-section-number">7.3.3</span> Bellman-Ford algorithm</h3>
<p>Unlike Dijkstra’s algorithm, the Bellman-Ford algorithm can handle graphs with negative edge weights, which might represent unfavorable or costly relationships in knowledge graphs.</p>
<div id="def-bellman-ford-algorithm" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.8 (Bellman-Ford algorithm)</strong></span> The <strong>Bellman-Ford algorithm</strong> computes shortest paths from a single source vertex to all other vertices in a weighted graph that may contain negative weight edges. It can also detect negative weight cycles.</p>
</div>
<div id="exm-bellman-ford-algorithm" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.8 (Bellman-Ford algorithm implementation)</strong></span> &nbsp;</p>
<pre><code>BELLMAN-FORD(G, w, s):
    for each vertex v in G.V
        v.distance = ∞
        v.predecessor = NIL
    s.distance = 0
    for i = 1 to |G.V| - 1
        for each edge (u, v) in G.E
            if v.distance &gt; u.distance + w(u, v)
                v.distance = u.distance + w(u, v)
                v.predecessor = u
    // Check for negative weight cycles
    for each edge (u, v) in G.E
        if v.distance &gt; u.distance + w(u, v)
            return FALSE  // Negative weight cycle detected
    return TRUE</code></pre>
</div>
<p>The time complexity of the Bellman-Ford algorithm is <span class="math inline">O(|V| \cdot |E|)</span>, which is less efficient than Dijkstra’s algorithm but offers broader applicability.</p>
</section>
</section>
<section id="minimum-spanning-trees" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="minimum-spanning-trees"><span class="header-section-number">7.4</span> Minimum spanning trees</h2>
<p>Minimum spanning trees (MSTs) identify the essential structure of a graph while minimizing total edge weight.</p>
<div id="def-minimum-spanning-tree" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.9 (Minimum spanning tree)</strong></span> A <strong>minimum spanning tree (MST)</strong> of a connected, undirected, weighted graph <span class="math inline">G = (V, E, w)</span> is a subgraph that is a tree and includes all vertices of <span class="math inline">G</span>, with minimum possible total edge weight.</p>
</div>
<p>In knowledge graphs, MSTs can help identify the core structure of relationships while minimizing redundancy or maximizing overall relationship strength.</p>
<section id="kruskals-algorithm" class="level3" data-number="7.4.1">
<h3 data-number="7.4.1" class="anchored" data-anchor-id="kruskals-algorithm"><span class="header-section-number">7.4.1</span> Kruskal’s algorithm</h3>
<p>Kruskal’s algorithm builds an MST by adding edges in order of increasing weight, skipping edges that would create cycles.</p>
<div id="exm-kruskal-algorithm" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.9 (Kruskal’s algorithm)</strong></span> &nbsp;</p>
<pre><code>KRUSKAL(G, w):
    A = ∅  // A will contain the edges of the MST
    for each vertex v in G.V
        MAKE-SET(v)  // Create a set for each vertex
    sort the edges of G.E into non-decreasing order by weight w
    for each edge (u, v) in G.E, in non-decreasing order by weight
        if FIND-SET(u) ≠ FIND-SET(v)
            A = A ∪ {(u, v)}
            UNION(u, v)
    return A</code></pre>
</div>
<p>The time complexity of Kruskal’s algorithm is <span class="math inline">O(|E| \log |E|)</span>, dominated by the sorting of edges.</p>
<div id="exm-kruskal-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.10 (Kruskal’s algorithm in a knowledge graph)</strong></span> Consider a knowledge graph representing scientific concepts, where edge weights represent the semantic distance between concepts. An MST would provide a minimal structure that connects all concepts while minimizing the total semantic distance. This could be useful for creating a simplified concept map for educational purposes.</p>
</div>
</section>
<section id="prims-algorithm" class="level3" data-number="7.4.2">
<h3 data-number="7.4.2" class="anchored" data-anchor-id="prims-algorithm"><span class="header-section-number">7.4.2</span> Prim’s algorithm</h3>
<p>Prim’s algorithm builds an MST by growing a single tree from a starting vertex, adding the minimum-weight edge that connects a vertex in the tree to a vertex outside the tree.</p>
<div id="exm-prims-algorithm" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.11 (Prim’s algorithm)</strong></span> &nbsp;</p>
<pre><code>PRIM(G, w, r):
    for each vertex u in G.V
        u.key = ∞
        u.predecessor = NIL
    r.key = 0
    Q = G.V
    while Q is not empty
        u = EXTRACT-MIN(Q)
        for each vertex v in G.Adj[u]
            if v in Q and w(u, v) &lt; v.key
                v.predecessor = u
                v.key = w(u, v)
                DECREASE-KEY(Q, v, v.key)</code></pre>
</div>
<p>The time complexity of Prim’s algorithm using a binary heap is <span class="math inline">O((|V| + |E|) \log |V|)</span>.</p>
</section>
</section>
<section id="topological-sorting" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="topological-sorting"><span class="header-section-number">7.5</span> Topological sorting</h2>
<p>Topological sorting is particularly relevant for directed acyclic graphs (DAGs), which represent hierarchical or dependency relationships in knowledge graphs.</p>
<div id="def-topological-sort" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.10 (Topological sort)</strong></span> A <strong>topological sort</strong> of a directed acyclic graph <span class="math inline">G = (V, E)</span> is a linear ordering of all vertices such that for every directed edge <span class="math inline">(u, v)</span>, vertex <span class="math inline">u</span> comes before vertex <span class="math inline">v</span> in the ordering.</p>
</div>
<div id="exm-topological-sort-algorithm" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.12 (Topological sort using DFS)</strong></span> &nbsp;</p>
<pre><code>TOPOLOGICAL-SORT(G):
    call DFS(G) to compute finish times v.f for each vertex v
    as each vertex is finished, insert it at the beginning of a linked list
    return the linked list of vertices</code></pre>
</div>
<p>The time complexity of topological sorting is <span class="math inline">O(|V| + |E|)</span>.</p>
<div id="exm-topological-sort-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.13 (Topological sorting in a knowledge graph)</strong></span> In an educational knowledge graph where concepts are linked by “prerequisite” relationships, a topological sort provides an optimal learning sequence. For example, in mathematics:</p>
<p>Input: Directed edges representing prerequisites</p>
<ul>
<li>(Arithmetic → Algebra)</li>
<li>(Arithmetic → Geometry)</li>
<li>(Algebra → Calculus)</li>
<li>(Geometry → Calculus)</li>
<li>(Calculus → Differential Equations)</li>
</ul>
<p>Output Topological Sort: Arithmetic, Algebra, Geometry, Calculus, Differential Equations</p>
</div>
</section>
<section id="graph-coloring-and-matching-problems" class="level2" data-number="7.6">
<h2 data-number="7.6" class="anchored" data-anchor-id="graph-coloring-and-matching-problems"><span class="header-section-number">7.6</span> Graph coloring and matching problems</h2>
<p>Graph coloring assigns labels (colors) to vertices or edges subject to certain constraints, while matching problems identify subsets of edges with no shared vertices.</p>
<div id="def-graph-coloring" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.11 (Graph coloring)</strong></span> A <strong>graph coloring</strong> is an assignment of labels (colors) to the vertices of a graph such that no adjacent vertices share the same color. The <strong>chromatic number</strong> of a graph is the minimum number of colors needed for a valid coloring.</p>
</div>
<div id="def-matching" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.12 (Matching)</strong></span> A <strong>matching</strong> in a graph is a set of edges without common vertices. A <strong>maximum matching</strong> is a matching with the largest possible number of edges.</p>
</div>
<div id="exm-bipartite-matching-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.14 (Bipartite matching in a knowledge graph)</strong></span> Consider a knowledge graph representing job applicants and positions, where edges indicate suitability for a position. A maximum bipartite matching would identify the optimal assignment of applicants to positions, maximizing the number of suitable placements.</p>
</div>
</section>
<section id="algorithm-complexity-analysis-for-graph-operations" class="level2" data-number="7.7">
<h2 data-number="7.7" class="anchored" data-anchor-id="algorithm-complexity-analysis-for-graph-operations"><span class="header-section-number">7.7</span> Algorithm complexity analysis for graph operations</h2>
<p>Understanding the computational complexity of graph algorithms is crucial for working with large-scale knowledge graphs that might contain millions or billions of nodes and edges.</p>
<div id="def-computational-complexity" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.13 (Computational complexity)</strong></span> The <strong>computational complexity</strong> of an algorithm is a measure of the amount of computational resources ( typically time and space) required by the algorithm as a function of the size of the input.</p>
</div>
<section id="time-complexity" class="level3" data-number="7.7.1">
<h3 data-number="7.7.1" class="anchored" data-anchor-id="time-complexity"><span class="header-section-number">7.7.1</span> Time complexity</h3>
<p>The time complexity of common graph algorithms on a graph with <span class="math inline">|V|</span> vertices and <span class="math inline">|E|</span> edges:</p>
<ol type="1">
<li>BFS and DFS: <span class="math inline">O(|V| + |E|)</span></li>
<li>Dijkstra’s algorithm: <span class="math inline">O((|V| + |E|) \log |V|)</span> with binary heap</li>
<li>Bellman-Ford: <span class="math inline">O(|V| \cdot |E|)</span></li>
<li>Kruskal’s algorithm: <span class="math inline">O(|E| \log |E|)</span></li>
<li>Prim’s algorithm: <span class="math inline">O((|V| + |E|) \log |V|)</span> with binary heap</li>
<li>Topological sort: <span class="math inline">O(|V| + |E|)</span></li>
</ol>
</section>
<section id="space-complexity" class="level3" data-number="7.7.2">
<h3 data-number="7.7.2" class="anchored" data-anchor-id="space-complexity"><span class="header-section-number">7.7.2</span> Space complexity</h3>
<p>Space complexity concerns the amount of memory required by an algorithm:</p>
<ol type="1">
<li>BFS: <span class="math inline">O(|V|)</span> for the queue</li>
<li>DFS: <span class="math inline">O(|V|)</span> for the recursion stack (worst case)</li>
<li>Dijkstra’s and Prim’s: <span class="math inline">O(|V|)</span> for the priority queue</li>
<li>Kruskal’s: <span class="math inline">O(|V|)</span> for the disjoint-set data structure</li>
</ol>
</section>
<section id="performance-considerations-for-knowledge-graphs" class="level3" data-number="7.7.3">
<h3 data-number="7.7.3" class="anchored" data-anchor-id="performance-considerations-for-knowledge-graphs"><span class="header-section-number">7.7.3</span> Performance considerations for knowledge graphs</h3>
<p>Knowledge graphs often have special characteristics that affect algorithm performance:</p>
<ol type="1">
<li><strong>Sparsity</strong>: Many knowledge graphs are sparse (|E| &lt;&lt; |V|²), which can be exploited for more efficient implementations.</li>
<li><strong>Scale</strong>: Real-world knowledge graphs can be enormous (billions of nodes and edges), requiring distributed processing.</li>
<li><strong>Heterogeneity</strong>: Different types of nodes and edges may require specialized algorithms or weighting schemes.</li>
<li><strong>Dynamism</strong>: Knowledge graphs often evolve over time, requiring incremental or online algorithms.</li>
</ol>
<div id="exm-complexity-large-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.15 (Complexity considerations for a large-scale knowledge graph)</strong></span> Consider a knowledge graph with 1 billion nodes and 10 billion edges:</p>
<ul>
<li>A naive adjacency matrix representation would require approximately 10^18 bits or 125,000 terabytes of storage, which is impractical.</li>
<li>Using an adjacency list representation reduces the space requirement to approximately 10 billion edge entries.</li>
<li>For such a graph, even linear-time algorithms like BFS would be challenging to run on a single machine, necessitating distributed processing techniques.</li>
</ul>
</div>
</section>
</section>
<section id="applications-in-knowledge-graph-analysis" class="level2" data-number="7.8">
<h2 data-number="7.8" class="anchored" data-anchor-id="applications-in-knowledge-graph-analysis"><span class="header-section-number">7.8</span> Applications in knowledge graph analysis</h2>
<p>The algorithms discussed have numerous applications in knowledge graph analysis:</p>
<section id="path-based-inference" class="level3" data-number="7.8.1">
<h3 data-number="7.8.1" class="anchored" data-anchor-id="path-based-inference"><span class="header-section-number">7.8.1</span> Path-based inference</h3>
<p>Path-based inference uses paths in the knowledge graph to derive new relationships or insights.</p>
<div id="exm-path-based-inference" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.16 (Path-based inference in a knowledge graph)</strong></span> In a biomedical knowledge graph:</p>
<ul>
<li><p>If drug A treats disease X</p></li>
<li><p>And disease X has symptom Y</p></li>
<li><p>And disease Z also has symptom Y</p></li>
<li><p>Path-based inference might suggest investigating drug A for disease Z</p></li>
</ul>
</div>
</section>
<section id="community-detection" class="level3" data-number="7.8.2">
<h3 data-number="7.8.2" class="anchored" data-anchor-id="community-detection"><span class="header-section-number">7.8.2</span> Community detection</h3>
<p>Community detection algorithms identify clusters of densely connected entities in knowledge graphs.</p>
<div id="def-community-detection" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.14 (Community detection)</strong></span> <strong>Community detection</strong> is the process of identifying groups of nodes in a graph that are more densely connected internally than with the rest of the graph.</p>
</div>
<p>Algorithms for community detection include:</p>
<ol type="1">
<li>Girvan-Newman algorithm (based on edge betweenness)</li>
<li>Louvain method (modularity optimization)</li>
<li>Label propagation</li>
<li>Spectral clustering</li>
</ol>
</section>
<section id="centrality-analysis" class="level3" data-number="7.8.3">
<h3 data-number="7.8.3" class="anchored" data-anchor-id="centrality-analysis"><span class="header-section-number">7.8.3</span> Centrality analysis</h3>
<p>Centrality measures help identify the most important entities in a knowledge graph.</p>
<div id="def-centrality-measures" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7.15 (Centrality measures)</strong></span> <strong>Centrality measures</strong> quantify the importance of vertices in a graph based on their position in the network structure.</p>
</div>
<p>Common centrality measures include:</p>
<ol type="1">
<li><strong>Degree centrality</strong>: The number of connections a node has.</li>
<li><strong>Betweenness centrality</strong>: The number of shortest paths passing through a node.</li>
<li><strong>Closeness centrality</strong>: The reciprocal of the sum of shortest path distances to all other nodes.</li>
<li><strong>Eigenvector centrality</strong>: A measure based on the principle that connections to high-scoring nodes contribute more to the score of a node than connections to low-scoring nodes.</li>
</ol>
<div id="exm-centrality-knowledge-graph" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.17 (Centrality in a citation knowledge graph)</strong></span> In a knowledge graph of scientific citations:</p>
<ul>
<li><p>Papers with high degree centrality are frequently cited (or cite many others)</p></li>
<li><p>Papers with high betweenness centrality connect different research areas</p></li>
<li><p>Papers with high closeness centrality have rapid influence across the network</p></li>
<li><p>Papers with high eigenvector centrality are cited by other important papers</p></li>
</ul>
</div>
</section>
</section>
<section id="recursive-and-iterative-approaches" class="level2" data-number="7.9">
<h2 data-number="7.9" class="anchored" data-anchor-id="recursive-and-iterative-approaches"><span class="header-section-number">7.9</span> Recursive and iterative approaches</h2>
<p>Many graph algorithms can be implemented using either recursive or iterative approaches, each with its own advantages.</p>
<div id="exm-recursive-vs-iterative-dfs" class="theorem example">
<p><span class="theorem-title"><strong>Example 7.18 (Recursive vs.&nbsp;iterative DFS)</strong></span> Recursive DFS implementation:</p>
<pre><code>DFS-VISIT(G, u):
    u.color = GRAY
    for each v in G.Adj[u]
        if v.color == WHITE
            v.predecessor = u
            DFS-VISIT(G, v)
    u.color = BLACK</code></pre>
<p>Iterative DFS implementation using a stack:</p>
<pre><code>DFS-ITERATIVE(G, s):
    for each vertex u in G.V
        u.color = WHITE
        u.predecessor = NIL
    s.color = GRAY
    STACK = empty stack
    PUSH(STACK, s)
    while STACK is not empty
        u = PEEK(STACK)
        if there exists a WHITE vertex v in G.Adj[u]
            v.color = GRAY
            v.predecessor = u
            PUSH(STACK, v)
        else
            u.color = BLACK
            POP(STACK)</code></pre>
</div>
<p>While recursive implementations are often more elegant and easier to understand, they can lead to stack overflow errors for very deep graphs. Iterative implementations using explicit data structures may be more robust for large-scale knowledge graphs.</p>
</section>
<section id="conclusion" class="level2" data-number="7.10">
<h2 data-number="7.10" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">7.10</span> Conclusion</h2>
<p>This chapter has explored fundamental graph algorithms for traversing, searching, and analyzing knowledge graphs. These algorithms form the computational foundation for extracting value from knowledge graphs, from basic operations like finding paths between entities to more complex analyses like community detection.</p>
<p>The choice of algorithm depends on the specific task, the structure of the knowledge graph, and computational constraints. Understanding the strengths, limitations, and complexity of different algorithms is essential for designing efficient solutions to knowledge graph problems.</p>
<p>In the next chapter, we will build upon these algorithmic foundations to explore statistical methods for analyzing knowledge graph properties, providing quantitative insights into the structure and patterns of complex networks.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="../../contents/construction/kg-construction.html" class="pagination-link" aria-label="Knowledge Graph Construction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Knowledge Graph Construction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../contents/construction/stat-analysis-of-kg.html" class="pagination-link" aria-label="Statistical Analysis of Knowledge Graphs">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Statistical Analysis of Knowledge Graphs</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="https://tuedsci.github.io/">© Tue Nguyen</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>